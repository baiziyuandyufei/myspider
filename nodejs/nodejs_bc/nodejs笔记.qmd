---
title: "Node.js模块"
author: "bzy"
format:
    html: default
    markdown: default
jupyter: python3
toc: true
toc-expand: true
---


# 模块

让我们结合示例来介绍模块。

## Node.js模块简介

Node.js的模块系统是其核心特性之一,允许开发者将代码分割成可重用的单元。模块可以是内置的、第三方的,或者是自定义的。一个.js文件就是一个模块，每一个模块都是单独的作用域。在该模块内定义的变量、函数、对象无法被其他模块读取。

### 模块类型

1. **内置模块**

例如下边代码中的`http`模块:

```{javascript}
const http = require('http');
```

这是Node.js的核心模块之一,用于创建HTTP服务器和客户端。

2. **第三方模块**

如下边示例中的`puppeteer`:

```{javascript}
const putteteer = require('puppeteer');
```

这是一个外部模块,需要通过npm安装。Puppeteer是一个用于控制Chrome或Chromium的高级API。

- （1）npm是什么？npm（Node package Manager, Node包管理器）
- （2）安装npm。安装了Node.js，那么npm就已经安装好了。
- （3）安装模块。

```{bash}
% npm install underscore

added 1 package, and audited 134 packages in 5s

14 packages are looking for funding
run `npm fund` for details

3 high severity vulnerabilities

To address all issues, run:
npm audit fix

Run `npm audit` for details.
```

- （4）使用模块。

```{javascript}
var _ = require('underscore');
_.each([1,2,3], function(num){
    console.log("underscore.js say " + num);
});
```

```{bash}
% node foo.js
underscore.js say 1
underscore.js say 2
underscore.js say 3
```

- （5）查找模块

```{bash}
% npm search puppeteer
puppeteer
A high-level API to control headless Chrome over the DevTools Protocol
Version 22.12.1 published 2024-06-26 by google-wombot
Maintainers: mathias google-wombot
Keywords: puppeteer chrome headless automation
https://npm.im/puppeteer
```

- （6）本地和全局的安装

本地安装意味着库将安装在项目本地的一个名为node_modules的文件夹下

有些模块带有可执行文件，你希望能够在文件系统的任何一个位置都能运行这些可执行文件。Express就是一个可能需要全局安装的模块示例。Express是Node.js的一个Web开发框架，带有一个能够创建站点骨架的生成器。

要全局安装模块，只需在安装时加上-g标记。

- （7）模块文档

查看文档

`% npm docs underscore`

查看bug

`% npm bugs underscore`

- （8）使用package.json指定以来关系

```{json}
{
    "name":"example02",
    "version":"0.0.1",
    "dependencies": {
        "underscore":"~1.2.1"
    }
}
```

```{bash}
% npm install

added 1 package, and audited 2 packages in 1s

found 0 vulnerabilities
```

```{bash}
% npm list
example02@0.0.1 /Users/feiyu/git_code/myspider/nodejs/nodejs_bc
└── underscore@1.2.4
```


3. **自定义模块**

下边示例中包含了自定义模块的使用:

```{javascript}
const { getLatLngAndDistance} = require('./baiduMap');
```

这行代码从当前目录下的`baiduMap.js`文件中导入了`getLatLngAndDistance`函数。

### 模块导出

模块可以导出对象、函数或变量,使其他文件能够使用它们。例如:

```{javascript}
module.exports = {
    getLatLngAndDistance
};
```

这段代码将`getLatLngAndDistance`函数作为对象的一个属性导出。

## 模块的优势

1. **代码组织**: 模块化使代码结构更清晰,易于维护。
2. **重用性**: 可以在多个项目中重用相同的模块。
3. **依赖管理**: 使用`package.json`可以轻松管理项目依赖。
4. **命名空间**: 模块提供了私有命名空间,避免全局变量污染。

## 使用模块的最佳实践

1. 遵循单一职责原则,每个模块专注于一个特定功能。
2. 使用语义化的命名,使模块的用途一目了然。
3. 适当使用`module.exports`和`exports`来导出功能。
4. 使用`const`声明导入的模块,防止意外修改。

通过合理使用模块,您可以构建出结构清晰、易于维护的Node.js应用程序。


好的,我很乐意为您介绍Node.js中的时间间隔定时器。让我们深入了解setInterval函数及其在Node.js中的应用。

# 时间间隔定时器

## setInterval函数概述

setInterval是Node.js中的一个全局函数,用于按照指定的时间间隔重复执行一段代码。它属于Node.js的定时器API的一部分。

### 基本语法

```javascript
setInterval(callback, delay[, ...args])
```

- callback: 要重复执行的函数
- delay: 执行间隔的毫秒数
- args: (可选) 传递给回调函数的额外参数

## setInterval的特点和用途

1. 周期性执行：适用于需要定期执行的任务,如轮询、定时检查或更新。

2. 持续运行：除非被清除,否则会一直执行。

3. 异步非阻塞：不会阻塞事件循环,允许其他代码继续执行。

4. 返回值：返回一个Timeout对象,可用于之后清除定时器。

## 实际应用示例

让我们分析您提供的代码片段:

```javascript
setInterval(() => refreshAndSendMessage(page), 5 * 60 * 1000);
```

这段代码的作用是:
- 每5分钟(5 * 60 * 1000毫秒)执行一次refreshAndSendMessage函数
- 传入page参数给refreshAndSendMessage函数
- 会持续执行,直到程序终止或手动清除定时器

## 注意事项和最佳实践

1. 内存管理：长时间运行的setInterval可能导致内存泄漏,需要适时清理。

2. 清除定时器：使用clearInterval(timeoutObject)来停止定时器。

3. 延迟精度：JavaScript的事件循环机制可能导致实际执行间隔略有偏差。

4. 避免嵌套：不建议在setInterval回调中再次使用setInterval,可能导致意外行为。

5. 考虑使用替代方案：对于某些场景,可能需要考虑使用setTimeout或更高级的调度库。

## 结论

setInterval是Node.js中一个强大的定时执行工具,适用于多种周期性任务场景。正确使用它可以大大提高应用的效率和功能性。但同时,开发者也需要注意其潜在的陷阱,确保在适当的时候清理定时器,并考虑任务的实际需求来选择最佳的定时策略。

# 函数

## JavaScript中的函数类型

### 1. 常规函数

常规函数是最基本的函数类型,有明确的名称和定义。

```javascript
function greet(name) {
  console.log(`Hello, ${name}!`);
}

greet('Alice'); // 输出: Hello, Alice!
```

常规函数可以在声明之前被调用(函数提升),适合创建可重用的代码块。

### 2. 匿名函数

匿名函数是没有名称的函数,通常作为参数传递或赋值给变量。

```javascript
const greet = function(name) {
  console.log(`Hello, ${name}!`);
};

greet('Bob'); // 输出: Hello, Bob!

// 作为参数传递
setTimeout(function() {
  console.log('Delayed message');
}, 1000);
```

匿名函数常用于需要临时函数的场景,如事件处理器或回调函数。

### 3. 回调函数

回调函数是作为参数传递给另一个函数,并在特定条件下被调用的函数。

```javascript
function fetchData(callback) {
  // 模拟异步操作
  setTimeout(() => {
    const data = { id: 1, name: 'John' };
    callback(data);
  }, 1000);
}

fetchData(function(result) {
  console.log(result); // 输出: { id: 1, name: 'John' }
});
```

回调函数广泛用于处理异步操作,如文件读写、网络请求等。

## 补充说明

1. **箭头函数**: ES6引入的简洁函数写法,通常用作匿名函数。

   ```javascript
   const greet = (name) => {
     console.log(`Hello, ${name}!`);
   };
   ```

2. **函数表达式**: 将函数赋值给变量的方式。

   ```javascript
   const greet = function(name) {
     console.log(`Hello, ${name}!`);
   };
   ```

3. **立即执行函数表达式(IIFE)**: 定义后立即执行的匿名函数。

   ```javascript
   (function() {
     console.log('This function is executed immediately');
   })();
   ```

这些函数类型和特性是JavaScript语言的核心部分,在各种JavaScript环境中(如浏览器、Node.js等)都可以使用。它们为开发者提供了灵活的编程方式,特别是在处理异步操作和创建模块化代码时非常有用。



# 1. Node.js介绍

## 1.1 什么是Node.js

Google的工程师们创建了**V8**，这是个给Google Chrome浏览器编写的JavaScript引擎，它也是专门为Web而设计的经过高度优化的软件。

Ryan Dahl决定使用V8引擎来创建JavaScript服务器端环境。**Node.js**是个事件驱动的服务器端JavaScript**环境**。

## 1.2 Node.js能做什么

Node.js是个程序设计平台，它既可以创建对文件系统进行操作的小段脚本，也可以创建大规模的Web应用程序来运行整个业务。

## 1.3 什么是服务器端的JavaScript？

使用JavaScript操纵浏览器中的Web页面并与之交互，这就是通常所称的客户端JavaScript，因为它发生在浏览器或者客户端。服务器端JavaScript发生在把页面发送给浏览器之前的**服务器上**。当然使用的是同样的语言。

## 1.4 安装并创建第一个Node.js程序

用于Windows和OSX的安装程序可以在Node.js的主页下载[https://nodejs.org/en](https://nodejs.org/en)

验证Node.js是否安装成功

```{javascript}
% node
Welcome to Node.js v20.14.0.
Type ".help" for more information.
> 1+1
2
```

创建 “Hello World” Node.js程序

```{javascript}
var http = require('http');
http.createServer(function (req, res){
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Hello World\n');
}).listen(3000, "127.0.0.1");
console.log('Server running at http://127.0.0.1:3000/');
```


## 1.5 小结

- 创建了一个简单的服务器。
- Node.js运行在V8引擎之上，V8是由Google开发的JavaScript引擎。
- Node.js精于创建有上千个并发用户的联网应用程序。

关于Node.js，并发的含义是什么？

Node.js的并发主要体现在以下几个方面:

1. 单线程异步模型：Node.js采用单线程事件循环模型，通过非阻塞I/O和事件驱动的方式实现并发[1][2]。这使得Node.js可以同时处理大量I/O操作而不会阻塞主线程。

2. 事件驱动：Node.js使用事件循环来处理异步操作，允许同时执行多个任务而不需要创建多个线程[2]。

3. 非阻塞I/O：Node.js的I/O操作是非阻塞的，这意味着在等待I/O完成时可以继续执行其他代码[1][2]。

4. 多进程：通过Cluster模块，Node.js可以创建多个子进程来利用多核CPU，实现真正的并行处理[3][4]。

5. 多线程：虽然Node.js主要是单线程的，但通过worker_threads模块可以创建多个线程来处理CPU密集型任务[1][2]。

6. 异步并发：使用Promise.all等方法可以同时发起多个异步操作，实现并发效果[1]。

7. 限制并发：通过使用工具如p-limit，可以控制并发数量，避免过度消耗资源[1]。

Node.js的并发模型特别适合I/O密集型应用，如Web服务器、数据库查询等[2][5]。它允许应用程序在等待I/O操作完成时继续处理其他任务，从而提高整体性能和吞吐量。然而，对于CPU密集型任务，可能需要使用多进程或多线程来充分利用多核CPU的优势[3][4]。

Citations:

- [1] https://juejin.cn/post/6934566591133089806
- [2] https://cloud.tencent.com/developer/article/1803406
- [3] https://blog.csdn.net/yuanlong12178/article/details/136373806
- [4] https://javascript-concurrency.gitbook.io/javascript-concurrency/09.-di-jiu-zhang-nodejs-gao-ji-bing-fa
- [5] https://xie.infoq.cn/article/d0b008f3fb992abf278c8b3b8

# 3. Node.js的作用

## 3.1 设计Node.js的目的

Node.js是创建在Chrome的JavaScript运行时之上的一个平台，用于简单构建快速的、可扩展的网络应用程序。**Node.js使用事件驱动的、非阻塞的I/O模型**，这让其既轻量又高效，是运行于不同发布设备上的数据密集型实时应用程序的完美平台。

## 3.4 联网的I/O是不可预测的

请求响应时间是不可预测的。

```{JavaScript}
var _ = require('underscore');
_.each([1,2,3], function(num){
    console.log("underscore.js say " + num);
});
```

```{text}
% node app.js 
Got response from edition.cnn.com
Request took:  530 ms
Got response from shapeshed.com
Request took:  548 ms
Got response from www.bbc.co.uk
Request took:  735 ms
```

```{text}
% node app.js
Got response from www.bbc.co.uk
Request took:  501 ms
Got response from edition.cnn.com
Request took:  502 ms
Got response from shapeshed.com
Request took:  521 ms
```

运行app.js为什么进程不结束

因为 http.get 是一个异步操作，并且 Node.js 的事件循环会保持运行直到所有的异步操作完成。**Node.js使用事件驱动的、非阻塞的I/O模型**。

## 3.5 人类是不可预测的

事件可在任何时刻发生，也可发生不止一次。我们将此描述为事件驱动的编程，因为在程序中要是有事情发生的话那么有个事件必须发生。事件驱动编程是处理不可预测性的极佳方式，因为我们可以识别将要发生的事件，即使我们并不知道事件什么时候会发生。

Node的事件化的I/O模型让我们无需担心互锁和并发这两个在多线程异步I/O中常见的问题。

# 4. 回调

## 4.1 什么是回调

回调指的是将一个函数作为参数传递给另一个函数，并且通常在第一个函数完成后被调用。

## 4.2 剖析回调

```{JavaScript}
function haveBreakfast(food, drink, callback){
    console.log('早餐食物：' + food + ', ' + drink);
    if (callback && typeof(callback) === "function"){
        callback();
    }
}

haveBreakfast('面包', '咖啡', function(){
    console.log('吃了饭，现在要工作了');
});
```

```{text}
% node app_callback.js 
早餐食物：面包, 咖啡
吃了饭，现在要工作了
```

回调的用途：haveBreakfast执行后，最后执行回调函数。

## 4.3 如何使用回调

```{javascript}
var http = require('http');

http.get({host: 'shapeshed.com'}, function(res){
    console.log("获取 shapeshed.com 的响应");
}).on('error', function(e){
    console.log("获取 shapeshed.com 时有一个错误")
});
```
```{text}
% node app_use_callback.js 
获取 shapeshed.com 的响应
```
为什么在终端执行node app_use_callback.js 后，进程一直没有结束？

```{text}
主要原因
Node.js 维护了一个事件循环，只要还有未完成的异步操作或活跃的监听器，进程就不会退出。在您的代码中，HTTP 客户端创建了一个持久连接，这个连接会保持打开状态，等待可能的后续请求。
详细解释
持久连接：
HTTP/1.1 默认使用持久连接（keep-alive）。这意味着 TCP 连接在完成初始请求后不会立即关闭，而是保持打开状态以便重用。
事件循环：
Node.js 的事件循环会继续运行，因为它检测到仍有活跃的网络连接。
隐式计时器：
HTTP 客户端可能设置了内部计时器来管理连接的生命周期，这些计时器也会保持事件循环活跃。
缺少显式关闭：
您的代码没有明确地关闭 HTTP 客户端或结束进程。
```

## 4.4 同步和异步代码

同步和阻塞这两个术语可互换使用，指的是代码的执行会在函数返回之前停止。如果某个操作阻塞，那么脚步就无法继续。对于最终用户而言，这意味着他们必须得等待。

Node.js中普通定义的函数，就是同步代码，一个函数接着一个函数执行。

```{javascript}
function sleep(millisceconds){
    var start = new Date().getTime();
    while((new Date().getTime() - start) < millisceconds);
}

function fetchPage(){
    console.log('获取 页面');
    sleep(2000);
    console.log('从页面返回数据');
}

function fetchApi(){
    console.log('获取 api');
    sleep(2000);
    console.log('从api返回数据')
}

fetchPage();
fetchApi();
```

```{text}
% node app_sync.js
获取 页面
从页面返回数据
获取 api
从api返回数据
```

异步和非阻塞这两个术语也可互换使用，指的是基于回调的、允许脚步并行执行操作的方法。脚步无需等待某个操作的结果才能继续进行，因为操作结果会在事件发生时由回调来处理。使用异步方法，操作无需一个接一个地发生。

```{javascript}
var http = require("http");

function fetchPage(){
    console.log('获取页面');
    http.get({host:'trafficjamapp.herokuapp.com',path: '/?delay=2000'},
        function(res){
            console.log('从页面获取到数据');
        }
    ).on('error', 
        function(e){
            console.log("获取页面发生以下错误: " + e);
        }
    );
}

function fetchApi() {
    console.log("获取api");
    http.get({host:'trafficjamapp.herokuapp.com', path: '/?delay=2000'},
        function (res){
            console.log("从api获取到数据");
        }
    ).on('error',
        function(err){
            console.log("获取api时发生以下错误: " + e);
    });
}

fetchPage();
fetchApi();
```

```{text}
% node app_async.js
获取页面
获取api
从页面获取到数据
从api获取到数据
```

## 4.5 事件循环

Node.js使用JavaScript的事件循环来支持它的异步编程风格。基本上，事件循环使得系统可以将回调函数先保存起来，而后当事件在将来发生时再运行。

# 6. Express介绍

## 6.·什么是Express

类似于Django

## 6.3 安装Express

`% npm install -g express-generator`

## 6.4 创建一个基础的Express站点

`% express express_example`

`npm start`

## 6.6 介绍Jade

### 6.6.1 使用Jade定义页面结构

### 6.6.2 使用Jade输出数据

#### 变量

#### 循环

#### 条件

#### 内联JS

#### 包含

#### Mixin


